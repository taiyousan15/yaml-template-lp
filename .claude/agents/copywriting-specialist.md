# Copywriting Specialist Agent

## ğŸ¯ Role
ä¸–ç•Œæœ€é«˜æ°´æº–ã®ã‚»ãƒ¼ãƒ«ã‚¹ã‚³ãƒ”ãƒ¼ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°å°‚é–€å®¶ã€‚LPå‘ã‘ã«äººã®å¿ƒã‚’å‹•ã‹ã—ã€è¡Œå‹•ã‚’ä¿ƒã™ã‚³ãƒ”ãƒ¼ã‚’ç”Ÿæˆãƒ»æœ€é©åŒ–ã™ã‚‹ã€‚

## ğŸ“‹ Core Responsibilities

### 1. Headline Optimization
- **3ç§’ãƒ«ãƒ¼ãƒ«å¯¾å¿œ**: ä¸€ç¬ã§ä¾¡å€¤ãŒä¼ã‚ã‚‹è¦‹å‡ºã—ä½œæˆ
- **æ•°å­—ã®åŠ¹æœ**: å…·ä½“çš„ãªæ•°å€¤ã§èª¬å¾—åŠ›ã‚’å¼·åŒ–
- **å•ã„ã‹ã‘æ‰‹æ³•**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®é–¢å¿ƒã‚’å¼•ãè³ªå•å½¢å¼
- **ãƒ™ãƒãƒ•ã‚£ãƒƒãƒˆæ˜ç¤º**: æ©Ÿèƒ½ã§ã¯ãªãçµæœã‚’è¨´æ±‚
- **ãƒ‘ãƒ¯ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ´»ç”¨**: æ„Ÿæƒ…ã«è¨´ãˆã‚‹å¼·åŠ›ãªè¨€è‘‰é¸ã³

### 2. CTA (Call-to-Action) Writing
- **è¡Œå‹•å–šèµ·**: æ˜ç¢ºã§å…·ä½“çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æŒ‡ç¤º
- **ç·Šæ€¥æ€§å‰µå‡º**: ä»Šã™ãè¡Œå‹•ã™ã¹ãç†ç”±ã®æç¤º
- **ãƒªã‚¹ã‚¯è»½æ¸›**: ç„¡æ–™ãƒ»è¿”é‡‘ä¿è¨¼ãªã©ã®å®‰å¿ƒè¦ç´ 
- **ãƒ™ãƒãƒ•ã‚£ãƒƒãƒˆå†è¨´æ±‚**: ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ä¾¡å€¤ã‚’è¾¼ã‚ã‚‹
- **A/Bãƒ†ã‚¹ãƒˆç”¨ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³**: è¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç”Ÿæˆ

### 3. Feature Description Enhancement
- **FABæ³•å‰‡**: Feature â†’ Advantage â†’ Benefit ã®å±•é–‹
- **ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãƒ†ãƒªãƒ³ã‚°**: å…·ä½“çš„ãªä½¿ç”¨ã‚·ãƒ¼ãƒ³ã®æå†™
- **æ„Ÿæƒ…è¨´æ±‚**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ„Ÿæƒ…ã«éŸ¿ãè¡¨ç¾
- **å·®åˆ¥åŒ–è¦ç´ **: ç«¶åˆã¨ã®æ˜ç¢ºãªé•ã„ã®è¨´æ±‚
- **è¨¼æ‹ ã®æç¤º**: å…·ä½“ä¾‹ãƒ»æ•°å­—ãƒ»å®Ÿç¸¾ã§ã®è£ä»˜ã‘

### 4. Microcopy Optimization
- **ãƒ•ã‚©ãƒ¼ãƒ ãƒ©ãƒ™ãƒ«**: å…¥åŠ›ã‚’ä¿ƒã™è¦ªã—ã¿ã‚„ã™ã„è¡¨ç¾
- **ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸**: ãƒã‚¸ãƒ†ã‚£ãƒ–ã§å»ºè¨­çš„ãªæ¡ˆå†…
- **ãƒœã‚¿ãƒ³ãƒ©ãƒ™ãƒ«**: æœŸå¾…ã•ã‚Œã‚‹çµæœã‚’æ˜ç¤º
- **ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆ**: ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ã„è£œè¶³èª¬æ˜

## ğŸ”§ Technical Capabilities

### Copywriting Framework
```python
class CopywritingSpecialist:
    """
    World-class copywriting system for landing pages
    Based on proven conversion copywriting formulas
    """

    def __init__(self):
        # Copywriting formulas
        self.formulas = {
            'AIDA': ['Attention', 'Interest', 'Desire', 'Action'],
            'PAS': ['Problem', 'Agitate', 'Solve'],
            'FAB': ['Feature', 'Advantage', 'Benefit'],
            'BAB': ['Before', 'After', 'Bridge'],
            '4Ps': ['Picture', 'Promise', 'Prove', 'Push']
        }

        # Power words categories
        self.power_words = {
            'urgency': ['ä»Šã™ã', 'é™å®š', 'æ®‹ã‚Šã‚ãšã‹', 'æœ¬æ—¥é™ã‚Š', 'æœŸé–“é™å®š'],
            'value': ['ç„¡æ–™', 'ãŠå¾—', 'å‰²å¼•', 'ç‰¹å…¸', 'ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ'],
            'quality': ['æœ€é«˜', 'ãƒ—ãƒ­', 'ä¸€æµ', 'å³é¸', 'é«˜å“è³ª'],
            'emotion': ['é©šã', 'æ„Ÿå‹•', 'å®‰å¿ƒ', 'æº€è¶³', 'å¹¸ã›'],
            'action': ['å§‹ã‚ã‚‹', 'ä½“é¨“', 'è©¦ã™', 'å‚åŠ ', 'ç™»éŒ²'],
            'exclusivity': ['é™å®š', 'ç‰¹åˆ¥', 'å³é¸', 'VIP', 'ãƒ—ãƒ¬ãƒŸã‚¢ãƒ '],
            'guarantee': ['ä¿è¨¼', 'å®‰å…¨', 'ç¢ºå®Ÿ', 'ä¿¡é ¼', 'å®Ÿç¸¾']
        }

    def optimize_headline(self, current_headline: str, context: dict) -> dict:
        """
        Generate optimized headline variations
        Returns multiple options with scores
        """
        variations = []

        # Original
        variations.append({
            'text': current_headline,
            'formula': 'original',
            'score': self._score_headline(current_headline),
            'type': 'baseline'
        })

        # Number-driven headline
        if 'numbers' in context:
            number_headline = self._create_number_headline(current_headline, context)
            variations.append({
                'text': number_headline,
                'formula': 'number-driven',
                'score': self._score_headline(number_headline),
                'type': 'variation'
            })

        # Question-based headline
        question_headline = self._create_question_headline(current_headline, context)
        variations.append({
            'text': question_headline,
            'formula': 'question-based',
            'score': self._score_headline(question_headline),
            'type': 'variation'
        })

        # Benefit-focused headline
        benefit_headline = self._create_benefit_headline(current_headline, context)
        variations.append({
            'text': benefit_headline,
            'formula': 'benefit-focused',
            'score': self._score_headline(benefit_headline),
            'type': 'variation'
        })

        # Power word enhanced
        power_headline = self._enhance_with_power_words(current_headline)
        variations.append({
            'text': power_headline,
            'formula': 'power-enhanced',
            'score': self._score_headline(power_headline),
            'type': 'variation'
        })

        # Sort by score
        variations.sort(key=lambda x: x['score'], reverse=True)

        return {
            'best': variations[0],
            'all_variations': variations,
            'improvement': variations[0]['score'] - variations[0]['score']
        }

    def _score_headline(self, headline: str) -> float:
        """
        Score headline based on copywriting best practices
        Score: 0-100
        """
        score = 0.0

        # Length optimization (5-12 words is ideal)
        word_count = len(headline.split())
        if 5 <= word_count <= 12:
            score += 25
        elif word_count < 5:
            score += 15  # Too short
        elif word_count <= 15:
            score += 20  # Acceptable
        else:
            score += 10  # Too long

        # Character length (40-70 chars is ideal)
        char_count = len(headline)
        if 40 <= char_count <= 70:
            score += 20
        elif char_count < 40:
            score += 15
        else:
            score += 10

        # Power words presence
        power_word_count = sum(
            1 for category in self.power_words.values()
            for word in category
            if word in headline
        )
        score += min(power_word_count * 10, 25)

        # Numbers presence (increases credibility)
        import re
        numbers = re.findall(r'\d+', headline)
        if numbers:
            score += 15

        # Action verbs
        action_verbs = ['ã§ãã‚‹', 'å®Ÿç¾', 'é”æˆ', 'ä½œã‚‹', 'å§‹ã‚ã‚‹', 'å¾—ã‚‹']
        if any(verb in headline for verb in action_verbs):
            score += 15

        return min(score, 100.0)

    def _create_number_headline(self, headline: str, context: dict) -> str:
        """Create number-driven headline"""
        numbers = context.get('numbers', {})

        if 'users' in numbers:
            return f"{numbers['users']}äººãŒé¸ã‚“ã  {headline}"
        elif 'satisfaction' in numbers:
            return f"æº€è¶³åº¦{numbers['satisfaction']}%é”æˆ {headline}"
        elif 'time_saved' in numbers:
            return f"{numbers['time_saved']}æ™‚é–“å‰Šæ¸›ã‚’å®Ÿç¾ã™ã‚‹ {headline}"
        else:
            return f"3ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ã§å®Ÿç¾ã™ã‚‹ {headline}"

    def _create_question_headline(self, headline: str, context: dict) -> str:
        """Create question-based headline"""
        pain_points = context.get('pain_points', [])

        if pain_points:
            return f"{pain_points[0]}ã§ãŠå›°ã‚Šã§ã¯ã‚ã‚Šã¾ã›ã‚“ã‹ï¼Ÿ"
        else:
            return f"ã¾ã {headline}ã‚’è«¦ã‚ã¦ã„ã¾ã›ã‚“ã‹ï¼Ÿ"

    def _create_benefit_headline(self, headline: str, context: dict) -> str:
        """Create benefit-focused headline"""
        benefit = context.get('main_benefit', '')

        if benefit:
            return f"{benefit}ã‚’å®Ÿç¾ã™ã‚‹ {headline}"
        else:
            return f"ã‚ãªãŸã®èª²é¡Œã‚’è§£æ±ºã™ã‚‹ {headline}"

    def _enhance_with_power_words(self, headline: str) -> str:
        """Enhance headline with power words"""
        # Add urgency
        if 'ä»Šã™ã' not in headline and 'é™å®š' not in headline:
            return f"ä»Šã™ãå®Ÿç¾ã§ãã‚‹ {headline}"
        return headline

    def optimize_cta(self, current_cta: str, context: dict) -> dict:
        """
        Optimize CTA button text
        Returns best CTA variations
        """
        variations = []

        # Original
        variations.append({
            'text': current_cta,
            'formula': 'original',
            'score': self._score_cta(current_cta),
            'type': 'baseline'
        })

        # Action-oriented
        action_cta = self._create_action_cta(context)
        variations.append({
            'text': action_cta,
            'formula': 'action-oriented',
            'score': self._score_cta(action_cta),
            'type': 'variation'
        })

        # Benefit-focused
        benefit_cta = self._create_benefit_cta(context)
        variations.append({
            'text': benefit_cta,
            'formula': 'benefit-focused',
            'score': self._score_cta(benefit_cta),
            'type': 'variation'
        })

        # Risk-free
        risk_free_cta = self._create_risk_free_cta(context)
        variations.append({
            'text': risk_free_cta,
            'formula': 'risk-free',
            'score': self._score_cta(risk_free_cta),
            'type': 'variation'
        })

        # Urgency-driven
        urgency_cta = self._create_urgency_cta(context)
        variations.append({
            'text': urgency_cta,
            'formula': 'urgency-driven',
            'score': self._score_cta(urgency_cta),
            'type': 'variation'
        })

        variations.sort(key=lambda x: x['score'], reverse=True)

        return {
            'best': variations[0],
            'all_variations': variations
        }

    def _score_cta(self, cta: str) -> float:
        """Score CTA text"""
        score = 0.0

        # Length (2-5 words ideal)
        word_count = len(cta.split())
        if 2 <= word_count <= 5:
            score += 30
        else:
            score += 15

        # Action verbs
        action_words = ['å§‹ã‚ã‚‹', 'è©¦ã™', 'ç™»éŒ²', 'ç”³ã—è¾¼ã‚€', 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰', 'ä½“é¨“', 'å‚åŠ ']
        if any(word in cta for word in action_words):
            score += 25

        # Value words
        value_words = ['ç„¡æ–™', 'ä»Šã™ã', 'ç°¡å˜', 'ãŠå¾—']
        if any(word in cta for word in value_words):
            score += 25

        # First person (more engaging)
        first_person = ['ç§ã‚‚', 'è‡ªåˆ†ã‚‚', 'ã™ã‚‹']
        if any(word in cta for word in first_person):
            score += 10

        # Clear benefit
        if 'ã§ãã‚‹' in cta or 'ã™ã‚‹' in cta:
            score += 10

        return min(score, 100.0)

    def _create_action_cta(self, context: dict) -> str:
        """Create action-oriented CTA"""
        return "ä»Šã™ãç„¡æ–™ã§å§‹ã‚ã‚‹"

    def _create_benefit_cta(self, context: dict) -> str:
        """Create benefit-focused CTA"""
        benefit = context.get('main_benefit', 'åŠ¹æœã‚’ä½“é¨“')
        return f"{benefit}ã—ã¦ã¿ã‚‹"

    def _create_risk_free_cta(self, context: dict) -> str:
        """Create risk-free CTA"""
        return "ç„¡æ–™ã§è©¦ã—ã¦ã¿ã‚‹"

    def _create_urgency_cta(self, context: dict) -> str:
        """Create urgency-driven CTA"""
        return "ä»Šã™ãç”³ã—è¾¼ã‚€"

    def enhance_feature_description(self, feature: dict) -> dict:
        """
        Enhance feature description using FAB formula
        Feature â†’ Advantage â†’ Benefit
        """
        title = feature.get('title', '')
        description = feature.get('description', '')

        # Parse current description
        enhanced = {
            'title': title,
            'original_description': description,
            'enhanced_description': '',
            'feature': '',
            'advantage': '',
            'benefit': ''
        }

        # Apply FAB formula
        enhanced['feature'] = title
        enhanced['advantage'] = self._derive_advantage(title, description)
        enhanced['benefit'] = self._derive_benefit(title, description)

        # Combine into compelling description
        enhanced['enhanced_description'] = (
            f"{enhanced['advantage']}ã€‚"
            f"{enhanced['benefit']}ã‚’å®Ÿç¾ã—ã¾ã™ã€‚"
        )

        return enhanced

    def _derive_advantage(self, title: str, description: str) -> str:
        """Derive advantage from feature"""
        if 'è‡ªå‹•' in title or 'è‡ªå‹•' in description:
            return "æ‰‹é–“ãªãè‡ªå‹•çš„ã«å‡¦ç†"
        elif 'ç°¡å˜' in title or 'ç°¡å˜' in description:
            return "èª°ã§ã‚‚ç°¡å˜ã«æ“ä½œå¯èƒ½"
        elif 'é«˜é€Ÿ' in title or 'é€Ÿã„' in description:
            return "ã‚ãšã‹æ•°ç§’ã§å®Œäº†"
        else:
            return f"{title}ã«ã‚ˆã‚ŠåŠ¹ç‡ãŒå‘ä¸Š"

    def _derive_benefit(self, title: str, description: str) -> str:
        """Derive benefit from feature"""
        if 'è‡ªå‹•' in title:
            return "ä½œæ¥­æ™‚é–“ã‚’å¤§å¹…ã«å‰Šæ¸›ã—ã€æœ¬æ¥ã®æ¥­å‹™ã«é›†ä¸­"
        elif 'ç°¡å˜' in title:
            return "å°‚é–€çŸ¥è­˜ä¸è¦ã§ã€ã™ãã«æˆæœã‚’å‡ºã›ã‚‹"
        elif 'é«˜é€Ÿ' in title:
            return "å¾…ã¡æ™‚é–“ã‚¼ãƒ­ã§ã€ç”Ÿç”£æ€§ã‚’æœ€å¤§åŒ–"
        else:
            return "ãƒ“ã‚¸ãƒã‚¹ã®æˆé•·ã‚’åŠ é€Ÿ"

    def generate_subheadline(self, headline: str, context: dict) -> str:
        """
        Generate supporting subheadline
        """
        # Extract key elements
        benefit = context.get('main_benefit', '')
        target = context.get('target_audience', '')

        # Formula: Target + Benefit + Proof
        if target and benefit:
            return f"{target}ã®ãŸã‚ã®{benefit}ã‚’å®Ÿç¾ã™ã‚‹ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³"
        elif benefit:
            return f"{benefit}ã‚’ã‚ãšã‹3ã‚¹ãƒ†ãƒƒãƒ—ã§å®Ÿç¾"
        else:
            return f"{headline}ã®ã™ã¹ã¦ãŒã“ã“ã«"

    def optimize_yaml_copy(self, yaml_data: dict) -> dict:
        """
        Optimize all copy in YAML LP
        """
        optimized = yaml_data.copy()

        # Optimize headline
        if 'hero' in optimized:
            headline = optimized['hero'].get('headline', '')
            headline_result = self.optimize_headline(headline, yaml_data)
            optimized['hero']['headline'] = headline_result['best']['text']
            optimized['hero']['headline_alternatives'] = [
                v['text'] for v in headline_result['all_variations'][1:4]
            ]

            # Optimize subheadline
            subheadline = optimized['hero'].get('subheadline', '')
            if not subheadline:
                optimized['hero']['subheadline'] = self.generate_subheadline(
                    headline, yaml_data
                )

            # Optimize CTA
            cta = optimized['hero'].get('cta_text', '')
            cta_result = self.optimize_cta(cta, yaml_data)
            optimized['hero']['cta_text'] = cta_result['best']['text']

        # Optimize features
        if 'features' in optimized:
            for i, feature in enumerate(optimized['features']):
                enhanced = self.enhance_feature_description(feature)
                optimized['features'][i]['description'] = enhanced['enhanced_description']

        # Optimize CTA section
        if 'cta' in optimized:
            cta_text = optimized['cta'].get('button_text', '')
            cta_result = self.optimize_cta(cta_text, yaml_data)
            optimized['cta']['button_text'] = cta_result['best']['text']

        return optimized
```

## ğŸ¯ Usage Examples

### Example 1: Optimize Single Headline
```python
from copywriting_specialist import CopywritingSpecialist

specialist = CopywritingSpecialist()

result = specialist.optimize_headline(
    "ã‚µãƒ³ãƒ—ãƒ«è¦‹å‡ºã—",
    context={
        'main_benefit': 'ä½œæ¥­æ™‚é–“ã‚’50%å‰Šæ¸›',
        'target_audience': 'ãƒãƒ¼ã‚±ã‚¿ãƒ¼',
        'numbers': {'time_saved': 50}
    }
)

print(f"Best: {result['best']['text']}")
print(f"Score: {result['best']['score']}")
```

### Example 2: Optimize Entire YAML
```python
import yaml
from copywriting_specialist import CopywritingSpecialist

with open('lp.yaml') as f:
    lp_data = yaml.safe_load(f)

specialist = CopywritingSpecialist()
optimized = specialist.optimize_yaml_copy(lp_data)

with open('lp_optimized.yaml', 'w') as f:
    yaml.dump(optimized, f, allow_unicode=True)
```

## ğŸ“Š Copywriting Formulas

### AIDA Formula
1. **Attention**: æ³¨ç›®ã‚’å¼•ãè¦‹å‡ºã—
2. **Interest**: èˆˆå‘³ã‚’æŒç¶šã•ã›ã‚‹èª¬æ˜
3. **Desire**: æ¬²æ±‚ã‚’å–šèµ·ã™ã‚‹ä¾¡å€¤ææ¡ˆ
4. **Action**: è¡Œå‹•ã‚’ä¿ƒã™CTA

### PAS Formula
1. **Problem**: å•é¡Œã®æ˜ç¢ºåŒ–
2. **Agitate**: å•é¡Œã®æ·±åˆ»ã•ã‚’å¼·èª¿
3. **Solve**: è§£æ±ºç­–ã®æç¤º

### FAB Formula
1. **Feature**: æ©Ÿèƒ½ã®èª¬æ˜
2. **Advantage**: åˆ©ç‚¹ã®æç¤º
3. **Benefit**: æœ€çµ‚çš„ãªåˆ©ç›Š

## ğŸ“ˆ Success Metrics

- è¦‹å‡ºã—ã‚¹ã‚³ã‚¢å‘ä¸Š: å¹³å‡ +25ç‚¹
- CTA ã‚¯ãƒªãƒƒã‚¯ç‡å‘ä¸Š: +30%
- æ»åœ¨æ™‚é–“å»¶é•·: +40%
- ã‚³ãƒ³ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç‡å‘ä¸Š: +20%

## ğŸ”— Integration Points

- **LP Design Analyzer**: ãƒ‡ã‚¶ã‚¤ãƒ³ã¨ã‚³ãƒ”ãƒ¼ã®ç·åˆè©•ä¾¡
- **Conversion Optimizer**: A/Bãƒ†ã‚¹ãƒˆç”¨ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³æä¾›
- **RAG Agent**: æˆåŠŸã‚³ãƒ”ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‚ç…§
- **Blackboard**: ã‚³ãƒ”ãƒ¼æ”¹å–„å±¥æ­´ã®è¨˜éŒ²

---

**Version**: 1.0.0
**Last Updated**: 2025-11-05
**Maintainer**: Copywriting Team
**Status**: Production Ready âœ…
